var tipuesearch = {"pages":[{"title":"About","text":"2016Fall 修課成員網誌","tags":"misc","url":"./pages/about/"},{"title":"繪製組合轉動正齒輪","text":"window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # 以 button 驅動的事件函式 def s3(e): x = 800/2 y = 700/2 if doc[\"na\"].value.isdigit(): n = int(doc[\"na\"].value) else: n = 50 if doc[\"nb\"].value.isdigit(): n2 = int(doc[\"nb\"].value) else: n2 = 25 def cangoGear(n, m, pa): # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth #m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 25 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm return gear # 設定兩齒齒數 reduced_ratio = 0.5 # 使用 80% 的畫布寬度 m = 0.8*canvas.width/((n+n2)*reduced_ratio) # 設定共同的壓力角 pa = 20 # n 齒輪的節圓半徑 pr = n*m/2 # n2 齒輪的節圓半徑 pr2 = n2*m/2 from time import time from browser.timer import request_animation_frame as raf from browser.timer import set_interval deg = math.pi/180 def draw(): cgo.clearCanvas() gear.rotate(2*deg) # 在特定位置, 以特定 scale, 特定 degs 執行 render # 設定囓合點在畫布正中央 # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標 #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0}) cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0}) # 根據兩齒輪齒數比決定 n2 齒輪轉速 gear1.rotate(-2*deg*n/n2) # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合 cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)}) set_interval(draw, 2) # 只使用畫布高度的 80% canvas_size = canvas.height*0.4 r17 = canvas_size*n2/(n+n2) r11 = r17*n2/n # 計算各齒輪中心座標 x17 = x -r17 y17 = y x11 = x +r11 y11 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x17, y17) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x17, -y17) gear = cangoGear(n, m, pa) cx = canvas.width/2 + 4 * n cy = canvas.height/2 # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x11, y11) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n2) ctx.translate(-x11, -y11) gear1 = cangoGear(n2, m, pa) ctx.restore() #判定 button s3(True) doc['button'].bind('click',s3) 程式碼如下: window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # 以 button 驅動的事件函式 def setgearnumber(e): x = 800/2 y = 700/2 if doc[\"na\"].value.isdigit(): n = int(doc[\"na\"].value) else: n = 50 if doc[\"nb\"].value.isdigit(): n2 = int(doc[\"nb\"].value) else: n2 = 25 def cangoGear(n, m, pa): # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth #m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 25 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm return gear # 設定兩齒齒數 reduced_ratio = 0.5 # 使用 80% 的畫布寬度 m = 0.8*canvas.width/((n+n2)*reduced_ratio) # 設定共同的壓力角 pa = 20 # n 齒輪的節圓半徑 pr = n*m/2 # n2 齒輪的節圓半徑 pr2 = n2*m/2 from time import time from browser.timer import request_animation_frame as raf from browser.timer import set_interval deg = math.pi/180 def draw(): cgo.clearCanvas() gear.rotate(2*deg) # 在特定位置, 以特定 scale, 特定 degs 執行 render # 設定囓合點在畫布正中央 # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標 #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0}) cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0}) # 根據兩齒輪齒數比決定 n2 齒輪轉速 gear1.rotate(-2*deg*n/n2) # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合 cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)}) set_interval(draw, 2) # 只使用畫布高度的 80% canvas_size = canvas.height*0.4 r17 = canvas_size*n2/(n+n2) r11 = r17*n2/n # 計算各齒輪中心座標 x17 = x -r17 y17 = y x11 = x +r11 y11 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x17, y17) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x17, -y17) gear = cangoGear(n, m, pa) cx = canvas.width/2 + 4 * n cy = canvas.height/2 # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x11, y11) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n2) ctx.translate(-x11, -y11) gear1 = cangoGear(n2, m, pa) ctx.restore() setgearnumber(True) doc['button'].bind('click',setgearnumber)","tags":"Course","url":"./gear3.html"},{"title":"繪製靜態組合正齒輪","text":"2-1 使用 canvas 畫出一個可自選齒數並組合之靜態正齒輪 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears from browser import document as doc from browser import html import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, rn 為齒數 # pa 為壓力角 (deg) # 已經針對 rn 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, rn=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/rn # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/rn # ra 為齒輪的外圍半徑 ra=rp+a # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*rn)+math.tan(pa*deg)-pa*deg for j in range(rn): ang=-2.*j*math.pi/rn+sigma ang2=2.*j*math.pi/rn+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/rn) lyd=midy-rd*math.cos(ang2-2.*math.pi/rn) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['ronegear'] ctx = canvas.getContext(\"2d\") # 以 button 驅動的事件函式 def set(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = (canvas.width)/2 y = (canvas.height)/2 if doc[\"rn1\"].value.isdigit(): n1 = int(doc[\"rn1\"].value) else: n1 = 50 if doc[\"rn2\"].value.isdigit(): n2 = int(doc[\"rn2\"].value) else: n2 = 25 # 只使用畫布高度的 80% canvas_size = canvas.height*0.4 r1 = canvas_size*0.8 r2 = r1 * n2 / n1 # 計算各齒輪中心座標 x1 = x - r1 y1 = y x2 = x+r2 y2 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x1, y1) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x1, -y1) gear1 = Spur(ctx).Gear(x1, y1, r1, n1, pa, \"blue\") # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x2, y2) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n2) ctx.translate(-x2, -y2) gear2 = Spur(ctx).Gear(x2, y2, r2, n2, pa, \"blue\") ctx.restore() set(True) doc['rbutton'].bind('click',set) 程式碼如下: 跳過程式碼請點此 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears from browser import document as doc from browser import html import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, rn 為齒數 # pa 為壓力角 (deg) # 已經針對 rn 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, rn=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/rn # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/rn # ra 為齒輪的外圍半徑 ra=rp+a # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*rn)+math.tan(pa*deg)-pa*deg for j in range(rn): ang=-2.*j*math.pi/rn+sigma ang2=2.*j*math.pi/rn+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/rn) lyd=midy-rd*math.cos(ang2-2.*math.pi/rn) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['ronegear'] ctx = canvas.getContext(\"2d\") # 以 button 驅動的事件函式 def set(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = (canvas.width)/2 y = (canvas.height)/2 if doc[\"rn1\"].value.isdigit(): n1 = int(doc[\"rn1\"].value) else: n1 = 50 if doc[\"rn2\"].value.isdigit(): n2 = int(doc[\"rn2\"].value) else: n2 = 25 # 只使用畫布高度的 80% canvas_size = canvas.height*0.4 r1 = canvas_size*0.8 r2 = r1 * n2 / n1 # 計算各齒輪中心座標 x1 = x - r1 y1 = y x2 = x+r2 y2 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x1, y1) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x1, -y1) gear1 = Spur(ctx).Gear(x1, y1, r1, n1, pa, \"blue\") # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x2, y2) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n2) ctx.translate(-x2, -y2) gear2 = Spur(ctx).Gear(x2, y2, r2, n2, pa, \"blue\") ctx.restore() set(True) doc['rbutton'].bind('click',set) 2-2 使用事先建立好的 cango 程式庫畫出兩個可自選齒數並組合之靜態正齒輪 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"rcango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"rcango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # 以 button 驅動的事件函式 def set1(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = 800/2 y = 700/2 if doc[\"rcn1\"].value.isdigit(): n = int(doc[\"rcn1\"].value) else: n = 50 if doc[\"rcn2\"].value.isdigit(): n2 = int(doc[\"rcn2\"].value) else: n2 = 25 def cangoGear(n, m, pa): # n 為齒數 # pa 為壓力角 #pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 25 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm return gear reduced_ratio = 0.5 # 使用 80% 的畫布寬度 m = 0.8*canvas.width/((n+n2)*reduced_ratio) # n 齒輪的節圓半徑 pr = n*m/2 # n2 齒輪的節圓半徑 pr2 = pr * n2 / n deg = math.pi/180 # 只使用畫布高度的 80% canvas_size = canvas.height*0.8 r1 = canvas_size*0.6 r2 = r1 * n2 / n # 計算各齒輪中心座標 x1 = x y1 = y x2 = x +r2+ r1/2 y2 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x1, y1) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x1, -y1) # 建立 gear gear = cangoGear(n, m, pa) ctx.restore() cx = canvas.width/2 + 4 * n cy = canvas.height/2 # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x2, y2) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n2) ctx.translate(-x2, -y2) # 建立 gear1 gear1 = cangoGear(n2, m, pa) ctx.restore() # 在特定位置, 以特定 scale, 特定 degs 執行 render # 設定囓合點在畫布正中央 # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標 #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0}) cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0}) # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合 cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)}) set1(True) doc['rcbutton'].bind('click',set1) 程式碼如下: window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"rcango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 #cobj = window.Cobj.new shape = window.Shape.new path = window.Path.new creategeartooth = window.createGearTooth.new tweener = window.Tweener.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"rcango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # 以 button 驅動的事件函式 def set1(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = 800/2 y = 700/2 if doc[\"rcn1\"].value.isdigit(): n = int(doc[\"rcn1\"].value) else: n = 50 if doc[\"rcn2\"].value.isdigit(): n2 = int(doc[\"rcn2\"].value) else: n2 = 25 def cangoGear(n, m, pa): # n 為齒數 # pa 為壓力角 #pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = shape(data, { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = path(shapedefs.circle(hr)) shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # setup the animation # backlash (mm) bklsh = 0.04*m # centre shift to make backlash dC = bklsh/(2*math.tan(math.pi*pa/180)) # np 為小齒輪齒數 np = 25 # gear ratio gr = n/np gearConfig = {'cx':-pr, 'cy':0, 'degs':[0, 360]} # gr*0.666 rpm #pinionConfig = {'cx':pr+dC, 'cy':0, 'degs':[0, -gr*360]} # 0.666 rpm return gear reduced_ratio = 0.5 # 使用 80% 的畫布寬度 m = 0.8*canvas.width/((n+n2)*reduced_ratio) # n 齒輪的節圓半徑 pr = n*m/2 # n2 齒輪的節圓半徑 pr2 = pr * n2 / n deg = math.pi/180 # 只使用畫布高度的 80% canvas_size = canvas.height*0.8 r1 = canvas_size*0.6 r2 = r1 * n2 / n # 計算各齒輪中心座標 x1 = x y1 = y x2 = x +r2+ r1/2 y2 = y pa = 20 # 開始繪製齒輪 # 儲存原有的座標系統 ctx.save() # 平移到齒輪圓心 ctx.translate(x1, y1) # 以齒輪圓心旋轉 90 度, 讓紅色標線在齒輪右側保持水平 ctx.rotate(90*deg) # 平移回原來的座標原點 ctx.translate(-x1, -y1) # 建立 gear gear = cangoGear(n, m, pa) ctx.restore() cx = canvas.width/2 + 4 * n cy = canvas.height/2 # 回復原有的座標系統 ctx.restore() ctx.save() ctx.translate(x2, y2) # 中間齒輪轉動 -90 度加上一齒, 可以與左側齒輪囓合 ctx.rotate(-90*deg-math.pi/n2) ctx.translate(-x2, -y2) # 建立 gear1 gear1 = cangoGear(n2, m, pa) ctx.restore() # 在特定位置, 以特定 scale, 特定 degs 執行 render # 設定囓合點在畫布正中央 # 囓合點往左偏 pr/2 即為 n 齒輪的圓心 x 座標 #cgo.render(gear, {'x':cx-pr*reduced_ratio, 'y':cy, 'scl':reduced_ratio, 'degs':0}) cgo.render(gear, {'x':cx-(pr+pr2)*reduced_ratio, 'y':cy, 'scl':0.5, 'degs':0}) # 囓合點往右偏 pr2/2 即為 n2 齒輪的圓心 x 座標, 且 n2 齒轉 180 加一齒角度後囓合 cgo.render(gear1, {'x':cx, 'y':cy, 'scl':reduced_ratio, 'degs':180+(360/n2/2)}) set1(True) doc['rcbutton'].bind('click',set1)","tags":"Course","url":"./gear2.html"},{"title":"繪製靜態組合正齒輪","text":"1-1 使用 canvas 畫出一個可自選齒數之靜態正齒輪 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") # 以 button 驅動的事件函式 def setgearnumber(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = (canvas.width)/2 y = (canvas.height)/2 if doc[\"n\"].value.isdigit(): n1 = int(doc[\"n\"].value) else: n1= 26 # 設定齒輪參數 x = (canvas.width)/2 y = (canvas.height)/2 r = 0.6*(canvas.height/2) pa = 20 # 繪出齒輪 Spur(ctx).Gear(x, y, r, n1, pa, \"blue\") #判定 button setgearnumber(True) doc['button'].bind('click',setgearnumber) 程式碼如下: 跳過程式碼請點此 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") # 以 button 驅動的事件函式 def setgearnumber(e): ctx.clearRect(0, 0, canvas.width, canvas.height) x = (canvas.width)/2 y = (canvas.height)/2 if doc[\"n\"].value.isdigit(): n1 = int(doc[\"n\"].value) else: n1= 26 # 設定齒輪參數 x = (canvas.width)/2 y = (canvas.height)/2 r = 0.6*(canvas.height/2) pa = 20 # 繪出齒輪 Spur(ctx).Gear(x, y, r, n1, pa, \"blue\") #判定 button setgearnumber(True) doc['button'].bind('click',setgearnumber) 1-2 使用事先建立好的 cango 程式庫畫出一個可自選齒數之靜態正齒輪 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = window.Cobj.new creategeartooth = window.createGearTooth.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # 以 button 驅動的事件函式 def draw(e): cgo.clearCanvas() cx = (canvas.width)/2 cy = (canvas.height)/2 if doc[\"cn\"].value.isdigit(): cn1 = int(doc[\"cn\"].value) else: cn1= 26 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.5*canvas.width/cn1 # pr 為節圓半徑 pr = cn1*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, cn1, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/cn1) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, cn1): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/cn1) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # render 繪出靜態正齒輪輪廓 gear.translate(cx, cy) cgo.render(gear) r = 0.6*(canvas.height/2) draw(True) doc['cbutton'].bind('click',draw) 程式碼如下: window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } Set Number of Gears # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = window.Cobj.new creategeartooth = window.createGearTooth.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # 以 button 驅動的事件函式 def draw(e): cgo.clearCanvas() cx = (canvas.width)/2 cy = (canvas.height)/2 if doc[\"cn\"].value.isdigit(): cn1 = int(doc[\"cn\"].value) else: cn1= 26 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.5*canvas.width/cn1 # pr 為節圓半徑 pr = cn1*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, cn1, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/cn1) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, cn1): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/cn1) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path # render 繪出靜態正齒輪輪廓 gear.translate(cx, cy) cgo.render(gear) r = 0.6*(canvas.height/2) draw(True) doc['cbutton'].bind('click',draw)","tags":"Course","url":"./gear1.html"},{"title":"2016fallcp期末考週","text":"期末考週 2017-01-13 15-16-18 from 40523215 on Vimeo . w15週心得與程式範例 心得 我覺得這一週教的東西沒有到很難,但是對我這個第一次 碰這些東西的人來說有一些些難度,但是我還是有點做出 東西的感覺 window.onload=function(){ brython(1); } from browser import document from browser import alert def get_input(ev): the_input= input(\"請輸入\") alert(\"輸入為:\"+str(the_input)) document['ch01'].bind('click',get_input) 取輸入後, 列印出來 def get_input(ev): the_input= input(\"請輸入\") alert(\"輸入為:\"+str(the_input)) document['ch01'].bind('click',get_input) from browser import document as doc from browser import html # 利用 document 根據 div 標註 id 設為 container 變數 container = doc['container'] # 因為此函式與滑鼠互動, 需要 event 當作輸入 def numPrint(ev): mystring = \"\" num = input(\"請輸入重複執行次數:\") #for i in range(1, 11): for i in range(1, int(num)+1): mystring += str(i) + \": hello mde\" + html.BR() container <= mystring # 與 id 為 'w13' 對應的 button 綁定, 且滑鼠 click 後, 呼叫 numPrint 函式執行 doc['w13'].bind('click',numPrint) 取重複執行次數後, 列印出來 w16週心得與程式範例 心得 這一週教的東西是和電腦玩猜數字,這感覺很不錯,原來這 樣一個小遊戲,就要打不少的程式,雖然遊戲不錯,但是自己 動手寫程式,還真有一些些困難 window.onload=function(){ brython(1); } from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲 id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess)","tags":"Course","url":"./2016fallcpqi-mo-kao-zhou.html"},{"title":"W16","text":"w16 window.onload=function(){ brython(1); } window.onload=function(){ brython(1); } from browser import document from browser import html import random id3 = document[\"id3\"] def guess(ev): # 清除 id3 中的內容 id3.clear() id3 <= \"開始玩猜數字遊戲\" + html.BR() 標準答案 = random.randint(1, 100) 你猜的數字 = int(input(\"請輸入您所猜整數:\")) 猜測次數 = 1 while 標準答案 != 你猜的數字: if 標準答案 < 你猜的數字: #print(\"太大了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太大了，再猜一次 :)加油\" + html.BR() else: #print(\"太小了，再猜一次 :)加油\") # 清除 id3 中的內容 id3.clear() id3 <= \"猜第\" + str(猜測次數) + \"次, 太小了，再猜一次 :)加油\" + html.BR() 你猜的數字 = int(input(\"請輸入您所猜整數:\")) 猜測次數 += 1 #print(\"猜對了！總共猜了\", 猜測次數, \"次\") id3 <= \"猜對了！答案為\" + str(標準答案) + \", 總共猜了\" + str(猜測次數) + \"次\" document[\"but3\"].bind(\"click\", guess) 玩猜數字遊戲","tags":"Course","url":"./w16.html"},{"title":"W15 練習","text":"window.onload=function(){ brython(1); } from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa from browser import document as do from browser import html c = do[\"con\"] def compa(e): your_input = input(\"請輸入一個整數!\") # 如何判斷所輸入的整數比 10 大 if int(your_input) > 10: c <= \"所輸入的整數:\" + your_input + \"比 10 大\" + html.BR() else: c <= \"所輸入的整數:\" + your_input + \"比 10 小\" + html.BR() #print(\"test\") ''' for i in range(5): c <= \"test\" + html.BR() ''' do[\"b1\"].bind(\"click\", compa) compa","tags":"Course","url":"./w15-lian-xi.html"},{"title":"W14 練習","text":"以下為第十四週開始的城市練習,要利用 http://mde.tw/2016fallcp/course/Python3Programs.txt 要整理Brython 的用法. window.onload=function(){ brython(1); } from browser import document as doc container = doc['ex1'] container<=\"W14練習\" from browser import document as doc from browser import html container = doc['ex2'] mystring = input(\"要印出什麼字串?\") mynum = input(\"要印幾次?\") for i in range(int(mynum)): #container<=\"W14練習-2\"+html.BR() container<=mystring+html.BR()","tags":"Misc","url":"./w14-lian-xi.html"},{"title":"W13","text":"畫線練習 畫線練習 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") ''' # 改用 background 函式繪圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ''' def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() # 設法利用運算印出吉他各把位的音名 def doreme(x, y, fontSize, order, ctx): # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #簡譜 1 2 3 4 5 6 7 #音名 C D E F G A B #唱名 Do Re Mi Fa Sol La Ti # 讓音名數列可以每 12 音名後, 升高 key 後從頭開始 if order > 12: order = order % 12 if order == 1: canvasText(x, y, fontSize, \"A\", \"\", \"\", \"black\", ctx) elif order ==2: canvasText(x, y, fontSize, \"B\", \"b\", \"\", \"red\", ctx) elif order == 3: canvasText(x, y, fontSize, \"B\", \"\", \"\", \"black\", ctx) elif order == 4: canvasText(x, y, fontSize, \"C\", \"\", \"\", \"black\", ctx) elif order == 5: canvasText(x, y, fontSize, \"D\", \"b\", \"\", \"red\", ctx) elif order == 6: canvasText(x, y, fontSize, \"D\", \"\", \"\", \"black\", ctx) elif order == 7: canvasText(x, y, fontSize, \"E\", \"b\", \"\", \"red\", ctx) elif order == 8: canvasText(x, y, fontSize, \"E\", \"\", \"\", \"black\", ctx) elif order == 9: canvasText(x, y, fontSize, \"F\", \"\", \"\", \"black\", ctx) elif order == 10: canvasText(x, y, fontSize, \"G\", \"b\", \"\", \"red\", ctx) elif order == 11: canvasText(x, y, fontSize, \"G\", \"\", \"\", \"black\", ctx) elif order == 12: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) else: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"20px Arial\" sixString = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] stringNum = 0 for i in sixString: ctx.fillText(i, x-7+stringNum*xinc, y-10) stringNum = stringNum + 1 num = 1 for j in range(1,20,1): ctx.fillText(j,50,95+num*yinc) num = num + 1 ctx.fill() ctx.stroke() ctx.closePath() # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #################################### # 以下利用數列運算, 從已知第1把位的音名分別推算各把位的音名 # 吉他初始音名次序 816(11)38 #################################### firstBar = [8, 1, 6, 11, 3, 8] # j 為往下增量 for j in range(19): # k 為 往右把位初始值 fontSize = 15 for k in range(6): bx = x + (k)*w - fontSize/3 by = y + (j)*h+h/2 + fontSize/2 order = firstBar[k] + j + 1 doreme(bx, by, fontSize, order, ctx) # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by #def ball(x, y, w, h , wcoord, hcoord, r, color, ctx): def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() #ctx.fillStyle = 'black' ctx.fillStyle = color #ctx.strokeStyle = \"black\" ctx.strokeStyle = color #ctx.arc(50, 80, 9, 0, 2*math.pi, False) ctx.arc(bx, by, r2, 0, 2*math.pi, False) # 為了疊上各把位的音名, 暫時不填色 #ctx.fill() ctx.stroke() ctx.closePath() x = 300 y = 200 w = 20 h = 30 # 將前面的水平線與垂直線繪圖改用 background 繪圖 background(100, 100, w, h, 5, 19, ctx) #background(x, y, w, h, 5, 4, ctx) #background(100, 300, 10, 10, 5, 4, ctx) #background(300, 100, 10, 10, 5, 12, ctx) # 配合 300, 300 的和絃背景, w=30, h=30, (1,1) 位置放入圓 #for i in range( 6): # for j in range(3): # ball(x, y, w, h, i+1, j+1, 'black', ctx) #ball(x, y, w, h, 1, 4, 'red', ctx) #ball(300, 300, 30, 20, 1, 1, 9, 'black', ctx)","tags":"Misc","url":"./w13.html"},{"title":"W12","text":"畫線練習 畫線練習 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") ''' # 改用 background 函式繪圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() ''' def canvasText(x, y, fontSize, string, sup, sub, color, ctx): # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = color ctx.strokeStyle = color #ctx.font = \"20px Arial\" ctx.font = str(fontSize)+ \"px Arial\" ctx.fillText(string, x, y) ctx.font = str(fontSize-8)+ \"px Arial\" if sup != \"\": ctx.fillText(sup, x+fontSize/1.6, y-fontSize/2) if sub != \"\": ctx.fillText(sup, x+fontSize/1.6, y) ctx.fill() ctx.stroke() ctx.closePath() # 設法利用運算印出吉他各把位的音名 def doreme(x, y, fontSize, order, ctx): # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #簡譜 1 2 3 4 5 6 7 #音名 C D E F G A B #唱名 Do Re Mi Fa Sol La Ti # 讓音名數列可以每 12 音名後, 升高 key 後從頭開始 if order > 12: order = order % 12 if order == 1: canvasText(x, y, fontSize, \"A\", \"\", \"\", \"black\", ctx) elif order ==2: canvasText(x, y, fontSize, \"B\", \"b\", \"\", \"red\", ctx) elif order == 3: canvasText(x, y, fontSize, \"B\", \"\", \"\", \"black\", ctx) elif order == 4: canvasText(x, y, fontSize, \"C\", \"\", \"\", \"black\", ctx) elif order == 5: canvasText(x, y, fontSize, \"D\", \"b\", \"\", \"red\", ctx) elif order == 6: canvasText(x, y, fontSize, \"D\", \"\", \"\", \"black\", ctx) elif order == 7: canvasText(x, y, fontSize, \"E\", \"b\", \"\", \"red\", ctx) elif order == 8: canvasText(x, y, fontSize, \"E\", \"\", \"\", \"black\", ctx) elif order == 9: canvasText(x, y, fontSize, \"F\", \"\", \"\", \"black\", ctx) elif order == 10: canvasText(x, y, fontSize, \"G\", \"b\", \"\", \"red\", ctx) elif order == 11: canvasText(x, y, fontSize, \"G\", \"\", \"\", \"black\", ctx) elif order == 12: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) else: canvasText(x, y, fontSize, \"A\", \"b\", \"\", \"red\", ctx) def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平線 for i in range(ynum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(xnum+1): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 標定各弦音符號, 以及把位編號 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"20px Arial\" sixString = [\"E\", \"A\", \"D\", \"G\", \"B\", \"E\"] stringNum = 0 for i in sixString: ctx.fillText(i, x-7+stringNum*xinc, y-10) stringNum = stringNum + 1 num = 1 for j in range(1,20,1): ctx.fillText(j,50,95+num*yinc) num = num + 1 ctx.fill() ctx.stroke() ctx.closePath() # EADGBE (guitar string) # FgGaAbBCdDeE (C=Do, D=Re, E=Mi) #################################### # 以下利用數列運算, 從已知第1把位的音名分別推算各把位的音名 # 吉他初始音名次序 816(11)38 #################################### firstBar = [8, 1, 6, 11, 3, 8] # j 為往下增量 for j in range(19): # k 為 往右把位初始值 fontSize = 15 for k in range(6): bx = x + (k)*w - fontSize/3 by = y + (j)*h+h/2 + fontSize/2 order = firstBar[k] + j + 1 doreme(bx, by, fontSize, order, ctx) # 一開始 x, y 為圓球圓心, 但是為了配合和弦繪圖 # 將 x, y 改為和弦的左上角座標 x, y # 配合 w, h, wcoord, hcoord 進行運算得到圓的圓心座標 bx, by #def ball(x, y, w, h , wcoord, hcoord, r, color, ctx): def ball(x, y, w, h , wcoord, hcoord, color, ctx): bx = x + (wcoord-1)*w by = y + (hcoord-1)*h+h/2 if w < h: r2 = w/2 -2 else: r2 = h/2 -2 ctx.beginPath() #ctx.fillStyle = 'black' ctx.fillStyle = color #ctx.strokeStyle = \"black\" ctx.strokeStyle = color #ctx.arc(50, 80, 9, 0, 2*math.pi, False) ctx.arc(bx, by, r2, 0, 2*math.pi, False) # 為了疊上各把位的音名, 暫時不填色 #ctx.fill() ctx.stroke() ctx.closePath() x = 300 y = 200 w = 20 h = 30 # 將前面的水平線與垂直線繪圖改用 background 繪圖 background(100, 100, w, h, 5, 19, ctx) #background(x, y, w, h, 5, 4, ctx) #background(100, 300, 10, 10, 5, 4, ctx) #background(300, 100, 10, 10, 5, 12, ctx) # 配合 300, 300 的和絃背景, w=30, h=30, (1,1) 位置放入圓 #for i in range( 6): # for j in range(3): # ball(x, y, w, h, i+1, j+1, 'black', ctx) #ball(x, y, w, h, 1, 4, 'red', ctx) #ball(300, 300, 30, 20, 1, 1, 9, 'black', ctx)","tags":"Misc","url":"./w12.html"},{"title":"W11","text":"畫線練習 畫線練習 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平 for i in range(ynum+1): ctx.beginPath() if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直 for i in range(xnum+1): ctx.beginPath() ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() background(50, 100, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"AMajor\", 50, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(90, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 85, 143) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(110, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 105, 143) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(130, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 125, 143) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(70, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(150, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 90, 5, 0, 2*math.pi, False) ctx.moveTo(45, 85) ctx.lineTo(55, 95) ctx.moveTo(55, 85) ctx.lineTo(45, 95) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(250, 100, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"CMajor\", 250, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(330, 113, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 325, 118) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(290, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 285, 143) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(270, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 265, 167) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(310, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(350, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(250, 90, 5, 0, 2*math.pi, False) ctx.moveTo(245, 85) ctx.lineTo(255, 95) ctx.moveTo(255, 85) ctx.lineTo(245, 95) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(450, 100, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"GMajor\", 450, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(470, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 465, 143) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(450, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 445, 167) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(530, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 525, 167) ctx.fill() ctx.stroke() ctx.closePath() # 4 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(550, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"4\", 545, 167) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(490, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(510, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(50, 300, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"DMajor\", 50, 270) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(110, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 105, 343) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(130, 362, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 125, 367) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(150, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 145, 343) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(90, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 390, 5, 0, 2*math.pi, False) ctx.moveTo(45, 285) ctx.lineTo(55, 295) ctx.moveTo(55, 285) ctx.lineTo(45, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 90, 5, 0, 2*math.pi, False) ctx.moveTo(65, 285) ctx.lineTo(75, 295) ctx.moveTo(75, 285) ctx.lineTo(65, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(250, 300, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"EMajor\", 250, 270) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(310, 313, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 305, 318) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(270, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 265, 343) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(290, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 285, 343) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(330, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # o ctx.beginPath() ctx.arc(350, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 390, 5, 0, 2*math.pi, False) ctx.moveTo(245, 285) ctx.lineTo(255, 295) ctx.moveTo(255, 285) ctx.lineTo(245, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(450, 300, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"Cmaj7\", 450, 270) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(490, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 485, 343) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(470, 362, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 465, 367) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(510, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # o ctx.beginPath() ctx.arc(530, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(550, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 390, 5, 0, 2*math.pi, False) ctx.moveTo(445, 285) ctx.lineTo(455, 295) ctx.moveTo(455, 285) ctx.lineTo(445, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() 上述: window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"chord1\"] ctx = canvas.getContext(\"2d\") def background(x, y, xinc, yinc, xnum, ynum, ctx): # 水平 for i in range(ynum+1): ctx.beginPath() if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(x-1, y+i*yinc) ctx.lineTo(x+xnum*xinc+1, y+i*yinc) ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直 for i in range(xnum+1): ctx.beginPath() ctx.lineWidth = 1 ctx.moveTo(x+i*xinc, y) ctx.lineTo(x+i*xinc, y+ynum*yinc) ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() background(50, 100, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"AMajor\", 50, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(90, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 85, 143) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(110, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 105, 143) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(130, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 125, 143) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(70, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(150, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 90, 5, 0, 2*math.pi, False) ctx.moveTo(45, 85) ctx.lineTo(55, 95) ctx.moveTo(55, 85) ctx.lineTo(45, 95) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(250, 100, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"CMajor\", 250, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(330, 113, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 325, 118) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(290, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 285, 143) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(270, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 265, 167) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(310, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(350, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(250, 90, 5, 0, 2*math.pi, False) ctx.moveTo(245, 85) ctx.lineTo(255, 95) ctx.moveTo(255, 85) ctx.lineTo(245, 95) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(450, 100, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"GMajor\", 450, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(470, 138, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 465, 143) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(450, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 445, 167) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(530, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 525, 167) ctx.fill() ctx.stroke() ctx.closePath() # 4 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(550, 162, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"4\", 545, 167) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(490, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(510, 90, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(50, 300, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"DMajor\", 50, 270) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(110, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 105, 343) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(130, 362, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 125, 367) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(150, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 145, 343) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(90, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 390, 5, 0, 2*math.pi, False) ctx.moveTo(45, 285) ctx.lineTo(55, 295) ctx.moveTo(55, 285) ctx.lineTo(45, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 90, 5, 0, 2*math.pi, False) ctx.moveTo(65, 285) ctx.lineTo(75, 295) ctx.moveTo(75, 285) ctx.lineTo(65, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(250, 300, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"EMajor\", 250, 270) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(310, 313, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 305, 318) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(270, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 265, 343) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(290, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 285, 343) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(330, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # o ctx.beginPath() ctx.arc(350, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 390, 5, 0, 2*math.pi, False) ctx.moveTo(245, 285) ctx.lineTo(255, 295) ctx.moveTo(255, 285) ctx.lineTo(245, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() background(450, 300, 20, 25, 5, 4, ctx) # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"Cmaj7\", 450, 270) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(490, 338, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 485, 343) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(470, 362, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 465, 367) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(510, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() #ctx.arc(150, 390, 5, 0, 2*math.pi, False) #ctx.lineWidth =3 #ctx.strokeStyle = \"black\" #ctx.stroke() #ctx.closePath() # o ctx.beginPath() ctx.arc(530, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(550, 290, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(50, 390, 5, 0, 2*math.pi, False) ctx.moveTo(445, 285) ctx.lineTo(455, 295) ctx.moveTo(455, 285) ctx.lineTo(445, 295) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath()","tags":"Misc","url":"./w11.html"},{"title":"W10","text":"畫線練習 畫線練習 window.onload=function(){ brython(1); } from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag1\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (100, 100) 座標點 ctx.moveTo(100, 100) # 然後畫直線到 (150, 200) 座標點 ctx.lineTo(150, 200) # 畫右上左下的斜線 ctx.moveTo(150, 100) ctx.lineTo(100, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag2\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 for i in range(5): ctx.moveTo(100+i*10, 100) ctx.lineTo(100+i*10, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() from browser import document as doc from browser import html import math import re # 準備繪圖畫布 canvas = doc[\"japanflag3\"] container = doc[\"container3\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"AMajor\", 100, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(140, 145, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 135, 150) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(160, 145, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 155, 150) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(180, 145, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 175, 150) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(120, 80, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(200, 80, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(100, 80, 5, 0, 2*math.pi, False) ctx.moveTo(95, 75) ctx.lineTo(105, 85) ctx.moveTo(105, 75) ctx.lineTo(95, 85) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag1\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (100, 100) 座標點 ctx.moveTo(100, 100) # 然後畫直線到 (150, 200) 座標點 ctx.lineTo(150, 200) # 畫右上左下的斜線 ctx.moveTo(150, 100) ctx.lineTo(100, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag2\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 for i in range(5): ctx.moveTo(100+i*10, 100) ctx.lineTo(100+i*10, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() from browser import document as doc from browser import html import math import re # 準備繪圖畫布 canvas = doc[\"japanflag3\"] container = doc[\"container3\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 水平線 for i in range(5): ctx.beginPath() # 設定線的寬度為 1 個單位 if i == 0: ctx.lineWidth = 7 else: ctx.lineWidth = 1 ctx.moveTo(99, 100+i*30) ctx.lineTo(201, 100+i*30) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 垂直線 for i in range(6): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 ctx.moveTo(100+i*20, 100) ctx.lineTo(100+i*20, 220) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" ctx.stroke() ctx.closePath() # 1 與 AMajor ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.font = \"30px Arial\" ctx.fillText(\"AMajor\", 100, 70) # 1 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(140, 145, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"1\", 135, 150) ctx.fill() ctx.stroke() ctx.closePath() # 2 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(160, 145, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"2\", 155, 150) ctx.fill() ctx.stroke() ctx.closePath() # 3 ctx.beginPath() ctx.fillStyle = 'black' ctx.strokeStyle = \"black\" ctx.arc(180, 145, 9, 0, 2*math.pi, False) ctx.fill() ctx.stroke() ctx.closePath() ctx.beginPath() ctx.fillStyle = 'white' ctx.font = \"16px Arial\" ctx.fillText(\"3\", 175, 150) ctx.fill() ctx.stroke() ctx.closePath() # o ctx.beginPath() ctx.arc(120, 80, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() ctx.beginPath() ctx.arc(200, 80, 5, 0, 2*math.pi, False) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath() # x ctx.beginPath() #ctx.arc(100, 80, 5, 0, 2*math.pi, False) ctx.moveTo(95, 75) ctx.lineTo(105, 85) ctx.moveTo(105, 75) ctx.lineTo(95, 85) ctx.lineWidth =3 ctx.strokeStyle = \"black\" ctx.stroke() ctx.closePath()","tags":"Misc","url":"./w10.html"},{"title":"2016Fall CP 學員連結","text":"利用計算機程式兩班選課名單可以產生個別成員的倉儲、筆記、投影片與網誌. 有關 Brython html 模組的用法, 請參考 http://www.brython.info/static_doc/en/html.html . 計算機程式甲班成員連結: window.onload=function(){ brython(1); } 甲班學員投影片: from browser import document, html container1 = document['container1'] adata = open(\"./../users/a.txt\").read() alist = adata.splitlines() n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2016fallcp_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container1 <= mlink 甲班學員網誌: from browser import document, html from script1 import alist container2 = document['container2'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2016fallcp_hw/blog\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container2 <= mlink 甲班學員 wiki: from browser import document, html from script1 import alist container3 = document['container3'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://github.com/s\"+str(stud_num)+\"/2016fallcp_hw/wiki\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container3 <= mlink 甲班學員倉儲: from browser import document, html from script1 import alist container4 = document['container4'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://github.com/s\"+str(stud_num)+\"/2016fallcp_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container4 <= mlink 乙班學員投影片: from browser import document, html container5 = document['container5'] adata = open(\"./../users/b.txt\").read() alist = adata.splitlines() n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2016fallcp_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container5 <= mlink 乙班學員網誌: from browser import document, html from script5 import alist container6 = document['container6'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2016fallcp_hw/blog\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container6 <= mlink 乙班學員 wiki: from browser import document, html from script5 import alist container7 = document['container7'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://github.com/s\"+str(stud_num)+\"/2016fallcp_hw/wiki\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container7 <= mlink 乙班學員倉儲: from browser import document, html from script5 import alist container8 = document['container8'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://github.com/s\"+str(stud_num)+\"/2016fallcp_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container8 <= mlink 上述連結代表處理程式: window.onload=function(){ brython(1); } 甲班學員投影片: from browser import document, html container1 = document['container1'] adata = open(\"./../users/a.txt\").read() alist = adata.splitlines() n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2016fallcp_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container1 <= mlink 甲班學員網誌: from browser import document, html # 學員選課名單直接從 id 為 script1 的程式段中導入 from script1 import alist container2 = document['container2'] n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2016fallcp_hw/blog\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container2 <= mlink","tags":"Course","url":"./2016fall-cp-xue-yuan-lian-jie.html"},{"title":"2016Fall CP 期中練習","text":"從 IPV6 相關 RFCs 查詢 得到的資料中, 如何在各組的網誌中整理一份能夠連結到各個未過時 (non-obsolete) 的 RFC 文件? 參考程式碼: data = open(\"midterm_list.txt\").read() line_list = data.splitlines() count = 0 for line in line_list: each_line_list = line.split(\"\\t\") try: if \"Obsoleted\" in each_line_list[5]: count = count + 1 print(each_line_list[0]) except: pass print(count) 接下來使用 Brython 程式碼, 將程式執行結果直接顯示在網頁上. 尚未失效的 IPV6 相關 RFC 如下: window.onload=function(){ brython(1); } from browser import document, html container = document['container'] data = open(\"./../midterm_list.txt\").read() line_list = data.splitlines() count = 0 output = \"\" for line in line_list: each_line_list = line.split(\"\\t\") try: if \"Obsoleted\" not in each_line_list[5]: count = count + 1 output += html.A(each_line_list[0], href=\"http://www.rfc-editor.org/info/\"+ each_line_list[0].lower().replace(\" \", \"\")) + \" | \" if count%10 == 0: output += html.BR() except: pass output += html.BR() + html.BR() + \"共有 \" + str(count)+ \" 份文件尚未失效!\" container <= output 提供上述結果的 Brython 程式如下: from browser import document, html container = document['container'] data = open(\"./../midterm_list.txt\").read() line_list = data.splitlines() count = 0 output = \"\" for line in line_list: each_line_list = line.split(\"\\t\") try: if \"Obsoleted\" not in each_line_list[5]: count = count + 1 output += html.A(each_line_list[0], href=\"http://www.rfc-editor.org/info/\"+ each_line_list[0].lower().replace(\" \", \"\")) + \" | \" if count%10 == 0: output += html.BR() except: pass output += html.BR() + html.BR() + \"共有 \" + str(count)+ \" 份文件尚未失效!\" container <= output","tags":"Misc","url":"./2016fall-cp-qi-zhong-lian-xi.html"},{"title":"2016Fall 程式練習題-12345","text":"1234已知截至第六週 2016fallcpa 的分組資料位於倉儲中的 w6_group.txt , 而從學校修課系統下載的修課人員名條則為 w6_list.txt , 請各組著手練習, 找出尚未納入分組的人員名單, 並研擬如何處置上課一個半月卻尚未進入情況的學員? 以下利用 Brython 讀取位於倉儲中","tags":"Misc","url":"./2016fall-cheng-shi-lian-xi-ti-12345.html"},{"title":"2016Fall 程式練習題-1234","text":"1234已知截至第六週 2016fallcpa 的分組資料位於倉儲中的 w6_group.txt , 而從學校修課系統下載的修課人員名條則為 w6_list.txt , 請各組著手練習, 找出尚未納入分組的人員名單, 並研擬如何處置上課一個半月卻尚未進入情況的學員? 以下利用 Brython 讀取位於倉儲中的 w6_list.txt 與 w6_group.txt 資料檔案. 表示學校教務系統中, 修 2016fallcpa 的學員名單為: window.onload=function(){ brython(1); } from browser import document, html container = document['container'] data = open(\"./../w6_list.txt\").read() container <= data 而截至 w6, 納入分組名單中的學員有: from browser import document, html container2 = document['container2'] data2 = open(\"./../w6_group.txt\").read() container2 <= data2 現在, 誰能夠幫我們找出至今尚未納入分組名單中的學員, 共有那些人？ from browser import document, html # 從 id=script1 程式區段取 data 變數 from script1 import data container3 = document['container3'] data3 = open(\"./../w6_group.txt\").read() group = data3.splitlines() # 希望將分組資料轉為學員數列, 令為變數名稱 result_g result_g = [] # 已經註冊者數列設為 registered registered = [] for line in group: # 去除每一行最後的空白成員 sline = line.split(\",\") # 再將各組拆成個別組員後, 串成 result_g for m in sline: result_g.append(m) #container3 <= len(sline) #container3 <= html.BR() #container3 <= len(result_g) registered = data.splitlines()[:-1] # 設法找出至今尚未分組的學員學號 not_in_group = [c for c in registered if c not in result_g] #container3 <= len(registered) -len(result_g) n = 1 for i in not_in_group: container3 <= \"第\"+str(n)+\"位: \"+ str(i) n = n + 1 container3 <= html.BR()","tags":"Misc","url":"./2016fall-cheng-shi-lian-xi-ti-1234.html"},{"title":"2016Fall 程式練習題","text":"已知截至第六週 2016fallcpa 的分組資料位於倉儲中的 w6_group.txt , 而從學校修課系統下載的修課人員名條則為 w6_list.txt , 請各組著手練習, 找出尚未納入分組的人員名單, 並研擬如何處置上課一個半月卻尚未進入情況的學員? 以下利用 Brython 讀取位於倉儲中的 w6_list.txt 與 w6_group.txt 資料檔案. 表示學校教務系統中, 修 2016fallcpa 的學員名單為: window.onload=function(){ brython(1); } from browser import document, html container = document['container'] data = open(\"./../w6_list.txt\").read() container <= data 而截至 w6, 納入分組名單中的學員有: from browser import document, html container2 = document['container2'] data2 = open(\"./../w6_group.txt\").read() container2 <= data2 現在, 誰能夠幫我們找出至今尚未納入分組名單中的學員, 共有那些人？ from browser import document, html # 從 id=script1 程式區段取 data 變數 from script1 import data container3 = document['container3'] data3 = open(\"./../w6_group.txt\").read() group = data3.splitlines() # 希望將分組資料轉為學員數列, 令為變數名稱 result_g result_g = [] # 已經註冊者數列設為 registered registered = [] for line in group: # 去除每一行最後的空白成員 sline = line.split(\",\") # 再將各組拆成個別組員後, 串成 result_g for m in sline: result_g.append(m) #container3 <= len(sline) #container3 <= html.BR() #container3 <= len(result_g) registered = data.splitlines()[:-1] # 設法找出至今尚未分組的學員學號 not_in_group = [c for c in registered if c not in result_g] #container3 <= len(registered) -len(result_g) n = 1 for i in not_in_group: container3 <= \"第\"+str(n)+\"位: \"+ str(i) n = n + 1 container3 <= html.BR()","tags":"Misc","url":"./2016fall-cheng-shi-lian-xi-ti.html"},{"title":"2016Fall 機械設計主題教學","text":"知識管理與最佳化應用實驗室試圖利用計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等課程, 進行與機械設計相關的主題式教學, 其中包含強化創造力的教學、令學員熟習六種工程表達方式, 並且俱備融入協同設計所需要的四大面向知識與技能. 機械設計主題教學 創造力三元素, 機械設計的六種表達, 協同設計的四大面向. 強化創造能力 - 自學力、程式力與想像力 (Creative Competencies) 熟習六種表達 - 口語、文字、2D、3D、理論與實體表達 (Six Presentation Methods) 融入協同設計 - 電腦、網路、軟硬體工具與協同專案 (Collaborative Designs) 計算機程式 從 Python3 的 print(), input(), 變數命名到關鍵字, 可以透過簡單的單位轉換問題進行練習: 首先我們舉 Python3 程式執行的三個地方: 在單機 Windows 10 操作系統環境下利用可攜程式系統執行 利用遠端桌面或 X-Windows, 在近端利用遠端的電腦硬體與操作系統執行 在近端利用瀏覽器執行 單機執行: 按下 start.bat 後, 系統就會配置好 git 與 Python3 的程式環境, 可以在命令列中直接用互動的方式執行 Python3 程式, 也可以在 SciTE 編輯器中, 透過設定按下 go 之後執行 所牽涉的問題: 可攜程式環境如何建立? Python3 執行環境如何配置? 執行的 Python3 是那一個版本? 希望在 SciTE 中直接執行 Python3 程式, 該如何設定? 能不能在 Leo Editor 中執行 Python3 程式, 為何要這樣做? 近端連到遠端執行: 以 Remote Desktop, 連接到遠端的電腦畫面中執行可攜程式系統中的 Python3 程式, 基本架構與流程與近端單機執行相同. 利用 putty 與 Xming, 連線到支援 X-Windows 協定的電腦, 將遠端的視窗搬到近端執行, 但仍使用遠端電腦的硬體與軟體支援. 在瀏覽器中執行: 由於網際瀏覽器環境所整合的工具愈來愈多, 就連原本只能在單機執行的 SolidWorks, 也已經有初步成型的 OnShape 可以取代部份的零組件設計分析工作, 因此本課程以 Brython 為例, 說明如何在瀏覽器中執行 Python3 程式. 所牽涉問題: 如何設置? Brython Console 所有近端能執行的程式都能利用瀏覽器執行? 以下使用 Brython 標準程式庫執行 Python3 繪圖程式: window.onload=function(){ brython(1); } # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc # 導入數學模組 import math # 產生各小球的亂數速度用 import random # 導入 browser 中的計時器, 建立動畫用 import browser.timer # 準備繪圖畫布 canvas = doc[\"plotarea\"] ctx = canvas.getContext(\"2d\") # 取畫布的寬與高度 width = canvas.width height = canvas.height n = 20 # 已知數列內容個數, 先分別與 None 對應 x = [None]*n y = [None]*n vy = [None]*n vx = [None]*n # 重力加速度, Y 方向向下為正 g = 0.05 # 空氣的黏滯阻尼係數 cor = 0.7 # 球的彈力係數 fr = 0.95 # 球的半徑 r = 5 for i in range(n): x[i] = 300 y[i] = 100 # random.random() 將會產生介於 0 與 1 的浮點亂數 vx[i] = 2*(random.random()-.5) vy[i] = 2*(random.random()-.5) # 更新第 i 球 Y 座標的運算邏輯 def updateY(i): if ((y[i]+r) < height): #y = height vy[i] += g else: vy[i] = -vy[i]*cor vx[i] *= fr y[i] += vy[i] if ((y[i]+r) > height): y[i] = height-r # 更新第 i 球 X 座標的運算邏輯 def updateX(i): if ((x[i]+r) >= width or (x[i]-r) <= 0): vx[i] = -vx[i]*cor x[i] += vx[i] if ((x[i]+r) > width): x[i] = width-r elif ((x[i]-r) < 0): x[i] = r # 畫圓函式 def circle(x,y,r): ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) ctx.fill() ctx.closePath() # 寫字函式 def text(s): ctx.fillStyle = \"#ff0000\" ctx.font = \"30px sans-serif\" ctx.textBaseline = \"bottom\" ctx.fillText(s,0,height) # 每隔特定時間, 進行動畫繪製 def animate(): # 刷新畫布 ctx.clearRect(0, 0, width, height) # 逐一重新繪製小球 ctx.fillStyle = \"#000000\" for i in range(n): updateY(i) updateX(i) circle(x[i],y[i],r) text(\"Click me!\") # 畫布點擊後執行的函式 def on_canvas_click(ev): browser.timer.set_interval(animate,0) # 只要使用者點擊在畫布上任何地方, 即執行 on_canvas_click 函式 canvas.bind('click', on_canvas_click, False) 上面小球自由落體的繪圖程式: <canvas id=\"plotarea\" width=\"600\" height=\"400\"></canvas> <script type=\"text/python3\"> # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc # 導入數學模組 import math # 產生各小球的亂數速度用 import random # 導入 browser 中的計時器, 建立動畫用 import browser.timer # 準備繪圖畫布 canvas = doc[\"plotarea\"] ctx = canvas.getContext(\"2d\") # 取畫布的寬與高度 width = canvas.width height = canvas.height n = 20 # 已知數列內容個數, 先分別與 None 對應 x = [None]*n y = [None]*n vy = [None]*n vx = [None]*n # 重力加速度, Y 方向向下為正 g = 0.05 # 空氣的黏滯阻尼係數 cor = 0.7 # 球的彈力係數 fr = 0.95 # 球的半徑 r = 5 for i in range(n): x[i] = 300 y[i] = 100 # random.random() 將會產生介於 0 與 1 的浮點亂數 vx[i] = 2*(random.random()-.5) vy[i] = 2*(random.random()-.5) # 更新第 i 球 Y 座標的運算邏輯 def updateY(i): if ((y[i]+r) < height): #y = height vy[i] += g else: vy[i] = -vy[i]*cor vx[i] *= fr y[i] += vy[i] if ((y[i]+r) > height): y[i] = height-r # 更新第 i 球 X 座標的運算邏輯 def updateX(i): if ((x[i]+r) >= width or (x[i]-r) <= 0): vx[i] = -vx[i]*cor x[i] += vx[i] if ((x[i]+r) > width): x[i] = width-r elif ((x[i]-r) < 0): x[i] = r # 畫圓函式 def circle(x,y,r): ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) ctx.fill() ctx.closePath() # 寫字函式 def text(s): ctx.fillStyle = \"#ff0000\" ctx.font = \"30px sans-serif\" ctx.textBaseline = \"bottom\" ctx.fillText(s,0,height) # 每隔特定時間, 進行動畫繪製 def animate(): # 刷新畫布 ctx.clearRect(0, 0, width, height) # 逐一重新繪製小球 ctx.fillStyle = \"#000000\" for i in range(n): updateY(i) updateX(i) circle(x[i],y[i],r) text(\"Click me!\") # 畫布點擊後執行的函式 def on_canvas_click(ev): browser.timer.set_interval(animate,0) # 只要使用者點擊在畫布上任何地方, 即執行 on_canvas_click 函式 canvas.bind('click', on_canvas_click, False) </script> 繪製日本國旗: 步驟1, 先能畫一條線: <canvas id=\"japanflag1\" width=\"600\" height=\"250\"></canvas> <script type=\"text/python3\"> from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag1\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (100, 100) 座標點 ctx.moveTo(100, 100) # 然後畫直線到 (150, 200) 座標點 ctx.lineTo(150, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() </script> from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag1\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (100, 100) 座標點 ctx.moveTo(100, 100) # 然後畫直線到 (150, 200) 座標點 ctx.lineTo(150, 200) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() 接著畫四條直線: <canvas id=\"japanflag2\" width=\"600\" height=\"400\"></canvas> <script type=\"text/python\"> # 導入 doc from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag2\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 因為要畫四條直線, 這裡要將畫直線改寫為函式 # 定義畫直線的函式, 以 (x1, y1) 為起點, 畫到 (x2, y2) def draw_line(x1, y1, x2, y2): global ctx ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() # 準備呼叫 draw_line() 四次以便畫出國旗外框四條線 # 假設從 (10, 10) 畫到 (410, 310) 的外框 # 先畫兩條水平線 draw_line(10, 10, 410, 10) draw_line(10, 310, 410, 310) # 再畫兩條垂直線 draw_line(10, 10, 10, 310) draw_line(410, 10, 410, 310) </script> # 導入 doc from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag2\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 因為要畫四條直線, 這裡要將畫直線改寫為函式 # 定義畫直線的函式, 以 (x1, y1) 為起點, 畫到 (x2, y2) def draw_line(x1, y1, x2, y2): global ctx ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() # 準備呼叫 draw_line() 四次以便畫出國旗外框四條線 # 假設從 (10, 10) 畫到 (410, 310) 的外框 # 先畫兩條水平線 draw_line(10, 10, 410, 10) draw_line(10, 310, 410, 310) # 再畫兩條垂直線 draw_line(10, 10, 10, 310) draw_line(410, 10, 410, 310) 接著在四條直線中央畫一個圓: <canvas id=\"japanflag3\" width=\"650\" height=\"450\"></canvas> <script type=\"text/python\"> from browser import document import math # 準備繪圖畫布 canvas = document[\"japanflag3\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 因為要畫四條直線, 這裡要將畫直線改寫為函式 # 定義畫直線的函式, 以 (x1, y1) 為起點, 畫到 (x2, y2) def draw_line(x1, y1, x2, y2): global ctx ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() # 準備呼叫 draw_line() 四次以便畫出國旗外框四條線 # 假設從 (10, 10) 畫到 (410, 310) 的外框 # 先畫兩條水平線 draw_line(10, 10, 410, 10) draw_line(10, 310, 410, 310) # 再畫兩條垂直線 draw_line(10, 10, 10, 310) draw_line(410, 10, 410, 310) # 以下要在框線中央畫一個圓, 設半徑為 80 # context.arc(x,y,r,sAngle,eAngle,counterclockwise) # arc(圓心 x, 圓心 y, 起始角, 終點角, 是否逆時鐘轉) circle_x = 10 + 400/2 circle_y = 10 + 300/2 ctx.beginPath() ctx.arc(circle_x, circle_y, 80, 0, math.pi*2, True) # 設線顏色為紅色 ctx.strokeStyle = 'rgb(255, 0, 0)' ctx.stroke() # 填色設為紅色 ctx.fillStyle = 'rgb(255, 0, 0)' ctx.fill() ctx.closePath() </script> from browser import document import math # 準備繪圖畫布 canvas = document[\"japanflag3\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 因為要畫四條直線, 這裡要將畫直線改寫為函式 # 定義畫直線的函式, 以 (x1, y1) 為起點, 畫到 (x2, y2) def draw_line(x1, y1, x2, y2): global ctx ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() # 準備呼叫 draw_line() 四次以便畫出國旗外框四條線 # 假設從 (10, 10) 畫到 (410, 310) 的外框 # 先畫兩條水平線 draw_line(10, 10, 410, 10) draw_line(10, 310, 410, 310) # 再畫兩條垂直線 draw_line(10, 10, 10, 310) draw_line(410, 10, 410, 310) # 以下要在框線中央畫一個圓, 設半徑為 80 # context.arc(x,y,r,sAngle,eAngle,counterclockwise) # arc(圓心 x, 圓心 y, 起始角, 終點角, 是否逆時鐘轉) circle_x = 10 + 400/2 circle_y = 10 + 300/2 ctx.beginPath() ctx.arc(circle_x, circle_y, 80, 0, math.pi*2, True) # 設線顏色為紅色 ctx.strokeStyle = 'rgb(255, 0, 0)' ctx.stroke() # 填色設為紅色 ctx.fillStyle = 'rgb(255, 0, 0)' ctx.fill() ctx.closePath() 然後將各繪圖模組寫成函式: <canvas id=\"japanflag4\" width=\"650\" height=\"450\"></canvas> <script type=\"text/python\"> # 導入 doc from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag4\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 因為要畫四條直線, 這裡要將畫直線改寫為函式 # 定義畫直線的函式, 以 (x1, y1) 為起點, 畫到 (x2, y2) def draw_line(ctx, x1, y1, x2, y2): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() # 將外框線寫成函式, 寬為高的 3/2 倍 # 因為 draw_frame 函式呼叫 draw_line() 因此要在其後定義 def draw_frame(ctx, x, y, w): # 準備呼叫 draw_line() 四次以便畫出國旗外框四條線 # 假設從 (x, y) 畫到 (410, 310) 的外框 # 先畫兩條水平線 draw_line(ctx, x, y, w*3/2+x, y) draw_line(ctx, x, w+y, w*3/2+x, w+y) # 再畫兩條垂直線 draw_line(ctx, x, y, x, w+y) draw_line(ctx, w*3/2+x, y, w*3/2+x, w+y) def draw_circle(x, y, r, fill=None): global ctx ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) if fill == None: ctx.fillStyle = 'rgb(255, 0, 0)' ctx.fill() else: ctx.strokeStyle = \"rgb(255, 0, 0)\" ctx.stroke() ctx.closePath() # 呼叫 draw_frame() width = 400 draw_frame(ctx, 10, 10, width) # 計算框的中心點座標 x_center = 10 + width*3/2/2 y_center = 10 + width/2 # 中間圓的直徑為寬的 3/5 radius = width*3/5/2 draw_circle(x_center, y_center, radius) </script> # 導入 doc from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"japanflag4\"] ctx = canvas.getContext(\"2d\") # 以下可以利用 ctx 物件進行畫圖 # 因為要畫四條直線, 這裡要將畫直線改寫為函式 # 定義畫直線的函式, 以 (x1, y1) 為起點, 畫到 (x2, y2) def draw_line(ctx, x1, y1, x2, y2): ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 將畫筆移動到 (x1, y1) 座標點 ctx.moveTo(x1, y1) # 然後畫直線到 (x2, y2) 座標點 ctx.lineTo(x2, y2) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() # 將外框線寫成函式, 寬為高的 3/2 倍 # 因為 draw_frame 函式呼叫 draw_line() 因此要在其後定義 def draw_frame(ctx, x, y, w): # 準備呼叫 draw_line() 四次以便畫出國旗外框四條線 # 假設從 (x, y) 畫到 (410, 310) 的外框 # 先畫兩條水平線 draw_line(ctx, x, y, w*3/2+x, y) draw_line(ctx, x, w+y, w*3/2+x, w+y) # 再畫兩條垂直線 draw_line(ctx, x, y, x, w+y) draw_line(ctx, w*3/2+x, y, w*3/2+x, w+y) def draw_circle(x, y, r, fill=None): global ctx ctx.beginPath() ctx.arc(x, y, r, 0, math.pi*2, True) if fill == None: ctx.fillStyle = 'rgb(255, 0, 0)' ctx.fill() else: ctx.strokeStyle = \"rgb(255, 0, 0)\" ctx.stroke() ctx.closePath() # 呼叫 draw_frame() width = 400 draw_frame(ctx, 10, 10, width) # 計算框的中心點座標 x_center = 10 + width*3/2/2 y_center = 10 + width/2 # 中間圓的直徑為寬的 3/5 radius = width*3/5/2 draw_circle(x_center, y_center, radius) 接下來畫中華民國國旗: # 導入 doc from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"rocflag\"] ctx = canvas.getContext(\"2d\") # 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點 # ctx.setTransform(1, 0, 0, -1, 0, canvas.height) # 以下採用 canvas 原始座標繪圖 flag_w = canvas.width flag_h = canvas.height circle_x = flag_w/4 circle_y = flag_h/4 # 先畫滿地紅 ctx.fillStyle='rgb(255, 0, 0)' ctx.fillRect(0,0,flag_w,flag_h) # 再畫青天 ctx.fillStyle='rgb(0, 0, 150)' ctx.fillRect(0,0,flag_w/2,flag_h/2) # 畫十二道光芒白日 ctx.beginPath() star_radius = flag_w/8 angle = 0 for i in range(24): angle += 5*math.pi*2/12 toX = circle_x + math.cos(angle)*star_radius toY = circle_y + math.sin(angle)*star_radius # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo if (i): ctx.lineTo(toX, toY) else: ctx.moveTo(toX, toY) ctx.closePath() # 將填色設為白色 ctx.fillStyle = '#fff' ctx.fill() # 白日:藍圈 ctx.beginPath() ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True) ctx.closePath() # 填色設為藍色 ctx.fillStyle = 'rgb(0, 0, 149)' ctx.fill() # 白日:白心 ctx.beginPath() ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True) ctx.closePath() # 填色設為白色 ctx.fillStyle = '#fff' ctx.fill() <canvas id=\"rocflag\" width=\"650\" height=\"450\"></canvas> <script type=\"text/python3\"> # 導入 doc from browser import document as doc import math # 準備繪圖畫布 canvas = doc[\"rocflag\"] ctx = canvas.getContext(\"2d\") # 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點 # ctx.setTransform(1, 0, 0, -1, 0, canvas.height) # 以下採用 canvas 原始座標繪圖 flag_w = canvas.width flag_h = canvas.height circle_x = flag_w/4 circle_y = flag_h/4 # 先畫滿地紅 ctx.fillStyle='rgb(255, 0, 0)' ctx.fillRect(0,0,flag_w,flag_h) # 再畫青天 ctx.fillStyle='rgb(0, 0, 150)' ctx.fillRect(0,0,flag_w/2,flag_h/2) # 畫十二道光芒白日 ctx.beginPath() star_radius = flag_w/8 angle = 0 for i in range(24): angle += 5*math.pi*2/12 toX = circle_x + math.cos(angle)*star_radius toY = circle_y + math.sin(angle)*star_radius # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo if (i): ctx.lineTo(toX, toY) else: ctx.moveTo(toX, toY) ctx.closePath() # 將填色設為白色 ctx.fillStyle = '#fff' ctx.fill() # 白日:藍圈 ctx.beginPath() ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True) ctx.closePath() # 填色設為藍色 ctx.fillStyle = 'rgb(0, 0, 149)' ctx.fill() # 白日:白心 ctx.beginPath() ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True) ctx.closePath() # 填色設為白色 ctx.fillStyle = '#fff' ctx.fill() </script>","tags":"Misc","url":"./2016fall-ji-jie-she-ji-zhu-ti-jiao-xue.html"}]};